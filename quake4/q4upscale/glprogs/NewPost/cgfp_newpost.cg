float Min3(float x, float y, float z)
{
    return min(x, min(y, z));
}

float Max3(float x, float y, float z)
{
    return max(x, max(y, z));
}


float rcp(float v)
{
	return 1.0 / v;
}

float3 CASPass(float2 texcoord, float viewportWidth, float viewportHeight, sampler2D diffuseImage)
{
    float Sharpness = 1;


    // fetch a 3x3 neighborhood around the pixel 'e',
    //  a b c
    //  d(e)f
    //  g h i
  //  int2 bufferSize = textureSize2D(diffuseImage);
    float pixelX = (1.0 / viewportWidth);
    float pixelY = (1.0 / viewportHeight);
   
    float3 a = tex2D(diffuseImage, texcoord + float2(-pixelX, -pixelY)).rgb;
    float3 b = tex2D(diffuseImage, texcoord + float2(0.0, -pixelY)).rgb;
    float3 c = tex2D(diffuseImage, texcoord + float2(pixelX, -pixelY)).rgb;
    float3 d = tex2D(diffuseImage, texcoord + float2(-pixelX, 0.0)).rgb;
    float3 e = tex2D(diffuseImage, texcoord).rgb;
    float3 f = tex2D(diffuseImage, texcoord + float2(pixelX, 0.0)).rgb;
    float3 g = tex2D(diffuseImage, texcoord + float2(-pixelX, pixelY)).rgb;
    float3 h = tex2D(diffuseImage, texcoord + float2(0.0, pixelY)).rgb;
    float3 i = tex2D(diffuseImage, texcoord + float2(pixelX, pixelY)).rgb;
 
    // Soft min and max.
	//  a b c             b
	//  d e f * 0.5  +  d e f * 0.5
	//  g h i             h
    // These are 2.0x bigger (factored out the extra multiply).
    float mnR = Min3( Min3(d.r, e.r, f.r), b.r, h.r);
    float mnG = Min3( Min3(d.g, e.g, f.g), b.g, h.g);
    float mnB = Min3( Min3(d.b, e.b, f.b), b.b, h.b);
    
    float mnR2 = Min3( Min3(mnR, a.r, c.r), g.r, i.r);
    float mnG2 = Min3( Min3(mnG, a.g, c.g), g.g, i.g);
    float mnB2 = Min3( Min3(mnB, a.b, c.b), g.b, i.b);
    mnR = mnR + mnR2;
    mnG = mnG + mnG2;
    mnB = mnB + mnB2;
    
    float mxR = Max3( Max3(d.r, e.r, f.r), b.r, h.r);
    float mxG = Max3( Max3(d.g, e.g, f.g), b.g, h.g);
    float mxB = Max3( Max3(d.b, e.b, f.b), b.b, h.b);
    
    float mxR2 = Max3( Max3(mxR, a.r, c.r), g.r, i.r);
    float mxG2 = Max3( Max3(mxG, a.g, c.g), g.g, i.g);
    float mxB2 = Max3( Max3(mxB, a.b, c.b), g.b, i.b);
    mxR = mxR + mxR2;
    mxG = mxG + mxG2;
    mxB = mxB + mxB2;
    
    // Smooth minimum distance to signal limit divided by smooth max.
    float rcpMR = rcp(mxR);
    float rcpMG = rcp(mxG);
    float rcpMB = rcp(mxB);

    float ampR = saturate(min(mnR, 2.0 - mxR) * rcpMR);
    float ampG = saturate(min(mnG, 2.0 - mxG) * rcpMG);
    float ampB = saturate(min(mnB, 2.0 - mxB) * rcpMB);
    
    // Shaping amount of sharpening.
    ampR = sqrt(ampR);
    ampG = sqrt(ampG);
    ampB = sqrt(ampB);
    
   // Filter shape.
   //  0 w 0
   //  w 1 w
   //  0 w 0  
   float peak = -rcp(lerp(8.0, 5.0, saturate(Sharpness)));
   
   float wR = ampR * peak;
   float wG = ampG * peak;
   float wB = ampB * peak;
   
   float rcpWeightR = rcp(1.0 + 4.0 * wR);
   float rcpWeightG = rcp(1.0 + 4.0 * wG);
   float rcpWeightB = rcp(1.0 + 4.0 * wB);
   
   float3 outColor = float3(saturate((b.r*wR+d.r*wR+f.r*wR+h.r*wR+e.r)*rcpWeightR),
                            saturate((b.g*wG+d.g*wG+f.g*wG+h.g*wG+e.g)*rcpWeightG),
                            saturate((b.b*wB+d.b*wB+f.b*wB+h.b*wB+e.b)*rcpWeightB));
 
    return outColor;
}


float3 LinearToneMap(float exposure, float3 hdrColor)
{
    const float gamma = 0.5;

    // Exposure tone mapping
   vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);
    // Gamma correction 
    mapped = pow(mapped, float3(1.0 / gamma));
  
    return mapped;
}

float3 Uncharted2ToneMapping(float3 color)
{
	const float gamma = 1.0;

	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 2.;
	color *= exposure;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
	color = pow(color, float3(1. / gamma));
	return color;
}

float4 blur9(sampler2D image, float2 vertTexCoord, float2 resolution, float2 direction) {
float2 texOffset = 1.0 / (resolution * 0.5);
  // Grouping texcoord variables in order to make it work in the GMA 950. See post #13
// in this thread:
// <a href="http://www.idevgames.com/forums/thread-3467.html" target="_blank" rel="nofollow">http://www.idevgames.com/forums/thread-3467.html</a>
vec2 tc0 = vertTexCoord.st + vec2(-texOffset.s, -texOffset.t);
vec2 tc1 = vertTexCoord.st + vec2(         0.0, -texOffset.t);
vec2 tc2 = vertTexCoord.st + vec2(+texOffset.s, -texOffset.t);
vec2 tc3 = vertTexCoord.st + vec2(-texOffset.s,          0.0);
vec2 tc4 = vertTexCoord.st + vec2(         0.0,          0.0);
vec2 tc5 = vertTexCoord.st + vec2(+texOffset.s,          0.0);
vec2 tc6 = vertTexCoord.st + vec2(-texOffset.s, +texOffset.t);
vec2 tc7 = vertTexCoord.st + vec2(         0.0, +texOffset.t);
vec2 tc8 = vertTexCoord.st + vec2(+texOffset.s, +texOffset.t);
 
vec4 col0 = tex2D(image, tc0);
vec4 col1 = tex2D(image, tc1);
vec4 col2 = tex2D(image, tc2);
vec4 col3 = tex2D(image, tc3);
vec4 col4 = tex2D(image, tc4);
vec4 col5 = tex2D(image, tc5);
vec4 col6 = tex2D(image, tc6);
vec4 col7 = tex2D(image, tc7);
vec4 col8 = tex2D(image, tc8);
 
vec4 sum = (1.0 * col0 + 2.0 * col1 + 1.0 * col2 + 
            2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
            1.0 * col6 + 2.0 * col7 + 1.0 * col8) / 16.0; 
	return sum;
}

void main( 
	   float4      diffuseST        : TEXCOORD0,

	   uniform sampler2D   litImage  : TEXUNIT0,
	   uniform sampler2D   albedoImage  : TEXUNIT1,
           out float4  color : COLOR)
{
    float2 texcoord = diffuseST.xy;

    float3 lit = tex2D(litImage, texcoord).rgb * 1.4;
    float3 albedo  = CASPass(texcoord, 1920, 1080, albedoImage);

    color.xyz = (lit + float3(0.1, 0.1, 0.1)) * albedo;
    color.a = 1;
}

